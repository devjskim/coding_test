# 알고리즘 문제 해결을 기록해 놓은 레포지토리
===================================

## 1. GCD: 최대 공약수 관련 문제

## 2. Prime Number

소수 찾기 관련 문제 풀이
(소수: 약수가 1 및 자기 자신 두개밖에 존재하지 않는 특별한 숫자)

PrimeN 함수: int N이 소수인지 판단하는 문제
  
    해당 숫자가 소수인지 판단하기 위해서 0 ~ N까지의 모든 숫자로 나눠보고 나머지가 0이 아님을 확인한다.

PrimeN2 함수: 
  
    int N이 소수인지 판단하는 문제
    해당 숫자가 소수인지 판단하기 위해서 0 ~ sqrt(N)까지의 모든 숫자로 나눠보고 나머지가 0이 아님을 확인한다.
    (0~N까지의 숫자를 모두 확인하지 않아도 sqrt(N)까지의 숫자만 확인해도 숫자가 소수인지 확인이 가능하다.)

erathos 함수: 소수를 찾기 위한 알고리즘인 에라토스테네스의 채를 활하여 해당한 문제
  
    해당 함수는 입력 N+1의 길이를 갖는 Boolean[] 배열을 만들어 반환한다.
    Boolean[] 배열은 각 index의 값이 소수인지 아닌지 표시해 둔 배열이다.(false: 소수, true: 소수아님)
    에라토스테네스의 채의 과정
        1. 2부터 N까지 모든 수를 써놓는다.
        2. 아직 지워지지 않은 수 중 가장 작은 수 i를 찾는다.(이는 소수이다.)
        3. i의 배수들을 모두 지운다.
        4. 이를 계속 반복한다. (i*i가 N을 넘을 경우에는 이를 멈춘다.)

goldbach 함수: 

    2보다 큰 모든 짝수는 두 소수(Prime number)의 합으로 나타낼 수 있다.
    5보다 큰 모든 홀수는 세 홀수의 합으로 나타낼 수 있다.
    아직 일반화된 증명은 이루어지지 않은 공식, 하지만 10^8까지는 증명을 마친 상태이다.


## N_for

check_sum 함수:

    문제 URL: https://www.acmicpc.net/problem/9095
    입력된 숫자를 1,2,3의 합으로 나타내는 함수
    N중 for loop 문만으로 작성
    문제의 조건 중 N이 1~10이라는 제한이 있기때문에 10개의 for loop를 중첩하여 구성
    
    	
## Brute force
 
    가능한 모든 경우의 수에 대해서 시도를 해보는 방법
    - 가능한 모든 방법을 모두 만들어 본다.(이때 모든 경우를 커버할 수 있어야 한다)
    - 만든 경우의 수를 활용하여 수를 계산한다.
    
dwarf:

    https://www.acmicpc.net/problem/2309
    9명의 난쟁이 중 7명을 선택하여 7명의 난쟁이의 키의 합이 100이 되는지 확인하는 함수
    9명 중 2명을 선별하여 이 둘을 제외하고 나머지 7명의 키의 합을 구하여 구현

ESM_date:

    https://www.acmicpc.net/problem/1476
    연도를 나타내는 주어진 세개의 숫자 E,S,M을 보고 현재가 몇년도 인지 확인하는 문제
    1<= E <= 15, 1<= S <= 28, 1<= M <= 19의 범위를 가진다.
    
## Permutation

    순열을 이용하여 해결할 수 있는 문제들의 집합
    
next_permu:
    
    입력으로 들어온 수열의 다음 수열을 구하는 문제
    순열의 순서는
    1,2,3,4 -> 1,2,4,3 ... -> 4,3,2,1의 순서
    O(N!)의 시간복잡도
    
    문제 해결 순서
    1. A[i] >= A[i-1]을 만족하는 가장 큰 i를 찾는다.
    2. j > i 이면서, A[j] <= A[i-1]을 만족하는 가장 큰 j를 찾는다.
    3. A[j], A[i-1]을 스왑한다.
    4. A[i] ~ A[N-1]을 역순으로 배열 한다.
    
prev_permu:
    
    next_permu와 반대로 이전 순서로 오는 순열을 구하는 문제
    
    문제 해결 순서
    1. A[i] <= A[i-1]을 만족하는 가장 큰 i를 찾는다.
    2. j >= i 이면서, A[j] >= A[i-1]을 만족하는 가장 큰 j를 찾는다.
    3. A[j], A[i-1]을 스왑한다.
    4. A[i] ~ A[N-1]을 역순으로 배열 한다.
    (next_permu에서 크기 비교를 반대로 수행하여 진행)
    
    
all_permu:
    
    모든 순열을 출력하는 함수
    
    입력된 배열을 초기화하여 오름차순으로 만든 뒤, next_permu를 마지막 순열이 나올떄까지 진행
    
TSP:
    
    https://www.acmicpc.net/problem/10971
    Traveling Salesman Problem
    N개의 도시가 있고, 이 곳을 모두 순회한다.
    도시 i에서 도시 j로 가는 비용은 w[i][j]이고 w[i][j]=0인 지점을 못 간다.
    
biggest_diff:

    https://www.acmicpc.net/problem/10819
    |A[0] - A[1]| + |A[1] - A[2]| + .... + |A[N-2] - A[N-1]의 값이 최대되는 순열을 구하고 그 값을 구한다.
    주어진 입력에 대하여 next_permu를 돌리며 이를 확인한다.